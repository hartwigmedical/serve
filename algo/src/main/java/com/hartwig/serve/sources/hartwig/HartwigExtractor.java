package com.hartwig.serve.sources.hartwig;

import java.util.List;
import java.util.Set;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.hartwig.serve.datamodel.Knowledgebase;
import com.hartwig.serve.datamodel.common.GeneRole;
import com.hartwig.serve.datamodel.common.ProteinEffect;
import com.hartwig.serve.datamodel.hotspot.ImmutableKnownHotspot;
import com.hartwig.serve.datamodel.hotspot.KnownHotspot;
import com.hartwig.serve.extraction.ExtractionResult;
import com.hartwig.serve.extraction.ImmutableExtractionResult;
import com.hartwig.serve.extraction.hotspot.Hotspot;
import com.hartwig.serve.extraction.hotspot.HotspotFunctions;
import com.hartwig.serve.extraction.hotspot.ImmutableHotspot;
import com.hartwig.serve.extraction.hotspot.ProteinResolver;
import com.hartwig.serve.extraction.util.KeyFormatter;
import com.hartwig.serve.util.ProgressTracker;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;

public class HartwigExtractor {

    private static final Logger LOGGER = LogManager.getLogger(HartwigExtractor.class);

    @NotNull
    private final Knowledgebase source;
    @NotNull
    private final ProteinResolver proteinResolver;
    private final boolean addExplicitHotspots;

    public HartwigExtractor(@NotNull final Knowledgebase source, @NotNull final ProteinResolver proteinResolver,
            final boolean addExplicitHotspots) {
        this.source = source;
        this.proteinResolver = proteinResolver;
        this.addExplicitHotspots = addExplicitHotspots;
    }

    @NotNull
    public ExtractionResult extract(@NotNull List<HartwigEntry> entries) {
        Set<KnownHotspot> knownHotspots = Sets.newHashSet();
        ProgressTracker tracker = new ProgressTracker("Hartwig", entries.size());
        for (HartwigEntry entry : entries) {
            List<Hotspot> hotspots = Lists.newArrayList();
            if (!entry.proteinAnnotation().isEmpty()) {
                hotspots = proteinResolver.resolve(entry.gene(), entry.transcript(), entry.proteinAnnotation());
            }

            if (addExplicitHotspots) {
                Hotspot explicitHotspot = toHotspot(entry);
                if (!hotspots.contains(explicitHotspot)) {
                    if (entry.proteinAnnotation().isEmpty()) {
                        LOGGER.debug(" Adding hotspot '{}' since protein annotation is not provided", explicitHotspot);
                    } else {
                        LOGGER.debug(" Adding hotspot '{}' since it was not generated by protein resolving based on '{}'",
                                explicitHotspot,
                                KeyFormatter.toProteinKey(entry.gene(), entry.transcript(), entry.proteinAnnotation()));
                    }
                    hotspots.add(explicitHotspot);
                }
            }

            for (Hotspot hotspot : hotspots) {
                knownHotspots.add(ImmutableKnownHotspot.builder()
                        .from(hotspot)
                        .ref(hotspot.ref())
                        .alt(hotspot.alt())
                        .gene(entry.gene())
                        .geneRole(GeneRole.UNKNOWN)
                        .proteinEffect(ProteinEffect.UNKNOWN)
                        .inputTranscript(entry.transcript())
                        .inputProteinAnnotation(entry.proteinAnnotation())
                        .addSources(source)
                        .build());
            }

            tracker.update();
        }

        // Even for Hartwig sources the extractor may generate duplicate hotspots, so we need to consolidate them.
        return ImmutableExtractionResult.builder()
                .refGenomeVersion(source.refGenomeVersion())
                .knownHotspots(HotspotFunctions.consolidate(knownHotspots))
                .build();
    }

    @NotNull
    private static Hotspot toHotspot(@NotNull HartwigEntry entry) {
        return ImmutableHotspot.builder()
                .chromosome(entry.chromosome())
                .position(entry.position())
                .ref(entry.ref())
                .alt(entry.alt())
                .build();
    }
}
